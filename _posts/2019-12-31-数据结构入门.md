---
layout:     post
title:      数据结构入门
subtitle:   NONE
date:       2019-12-31
author:     Pkun
header-img: 
catalog: true
tags:
---

# 数据结构

在编写代码的过程中往往需要使用不同的方式来组织数据，以此达到更高的效率，正好赶上期末复习，写篇blog来系统的复习一下常用的数据结构

## 线性表

线性表是$n$个数据元素的有限序列$(a_1,a_2,a_3,...,a_n)$，除了第一个元素外每个元素都有一个直接前驱，除了最后一个元素外，每个元素有一个直接后继

***顺序表*** 就是元素的逻辑先后顺序与其物理存放顺序一致

### 数组

线性表储存在连续的物理空间中，可以通过下标访问

### 链表

不是连续存储的，扩充很方便，对链表来说有很多的变形

- 带附加头节点（本身没有数据）的单链表，插入删除更方便
- 循环链表，表尾不再指向`null`而是指向表头
- 双向链表，不仅指向后面的，还指向前面的
- 静态链表，为数组中的每一个元素附加一个链接指针，不改变元素的物理位置，但是可以改变元素的逻辑顺序

## 栈和队列

### 栈

一种后进先出的数据结构，在调用需要回溯时很管用（递归）

- 双栈

### 队列

一种先进先出的数据结构，在线程调度和分配中常用到

- 循环队列
- 优先级队列
  - 每个元素都有一个优先级，每次从队列中取出优先级最高的元素

## 数组，字符串，广义表

### 多维数组（矩阵）

稀疏矩阵与快速转置法

### 字符串

KMP匹配算法

### 广义表

没啥用

## 树

### 二叉树

- 完全二叉树

二叉树可以用数组和链表来表述，用数组表示的时候可以快速的访问节点和他的子女双亲，对节点做操作会比较快。

在递归可以很好的解决的时候用链表实现起来可能会比较方便。

### 线索二叉树

线索是指向前驱和后继的指针，前中后序遍历的时候速度更快

### 森林

很多树，也有前中后根遍历，不过要先把森林变成二叉树‘

### 堆

优先级队列的一种实现，逻辑上是完全二叉树的结构，物理上是数组，通过下标访问

- 最大/最小堆
- 堆排序

### 哈夫曼树

编码用的

## 字典和集合

### 集合

懂得都懂，数量不多的时候可以用数组表示（如果在就是1，不在就是0），也可以用链表表示

### 等价类

集合通过某种等价关系来划分成若干个互不相交的子集

- 有一个算法，每次将等价的元素接到一起，用链表和栈，复杂度是O(等价对个数+对象个数)

### 并查集

- Union（）
- Find
  - 压缩路径算法：从i到根的路径上的每一个节点都让双亲变成根

在设计各种等价关系的问题上非常好用，对于属于同一集合的元素，可以用find+union迅速合并，一般用数组

### 字典

key-value对

### 散列

利用一个`hash()`函数将key和value对应起来，快速查找，时间复杂度可以达到O(1)

- 碰撞检测

  - 线性探查

  - 二次探查

  - 双散列

- 散列函数
  - 直接定址
  - 除留余数
  - 平方取中

## 搜索结构

### 二叉搜索树

左子树上所有节点的关键码都小于根节点的关键码，右子树上所有节点的关键码都大于根节点的关键码，左右子树也都是二叉搜索树

### AVL

可以旋转的二叉搜索树，让树的高度恒定在$log_2n$，查找效率最好最坏都是$O(log_2 n)$

- 左旋 右旋
- 左右双旋 右左双旋

## 图

### 表示法

- 邻接矩阵
- 邻接表

### 遍历

- 深搜
- 广搜

### 最小生成树

- Kruskal算法 $O(elog_2e+elog_2n+n^2+n)$
  - 将所有边排序，然后不断从中取边，最后组成一棵最小生成树

- Prim算法 O(n^2)
  - 每次从一个已经有的点出发，每次选择一条边，这条边是(u,v)中权最小的边，$u \in U, v \in V-U, $其中$U$是最小生成树中已有的点，$V$是剩下的点

Kruskal适合边少的图，Prim算法适合边多的图

### 最短路

- Dijkstra算法
  - 思想和Prim差不多

- Bellman-Ford算法和Floyd算法
  - 其实就是遍历了整个图

Dijkstra不能处理负边，Bellman-Ford和Floyd可以

### 活动网络

- AOV
  - 拓扑排序
- AOE
  - 关键路径
  - 前向传播和反向传播（动态规划？）

## 文件和索引

### B树和B+树

### 红黑树