---
layout:     post
title:      Java对象生死簿
subtitle:   深入理解Java虚拟机
date:       2020-03-19
author:     Pkun
header-img: 
catalog: true
tags: Java虚拟机

---

## 前言

GC并不是Java语言特有的技术，实际上OO作为一种观念和想法，提出的时间也在Java之前。Lisp是第一门开始使用内存动态分配和垃圾收集的语言。

对于垃圾收集，Lisp的作者思考过以下三件事情：

-  哪些内存需要回收 
-  哪些内存需要回收 
- 什么时候回收
- 如何回收

经过技术的发展，现在GC和内存动态分配已经非常成熟，学习这些技术是为了出现内存溢出和泄露问题的时候，我们可以对这些技术进行监控来施行必要的调节。

在Java内存区域中，程序计数器，虚拟机栈，本地方法栈的生命周期和他对应的线程一样，这几个区域的内存分配和回收都具有确定性，但是Java堆和方法区不一样，一个方法内部会执行哪些分支只有运行期间我们才能搞明白，所以这一块具有非常强的动态性，GC所关注的也正是这部分内存的管理。

## 对象是生是死？

只有死去的对象才会被GC消灭，那么我们如何确认对象的状态？

### 引用计数法

引用计数法是一种非常简单的判断对象是否存活的方法，它的想法是基于一个对象是否被引用来判断生死的，因此对每个对象都有一个计数器，如果它被别的地方引用，计数器就++，否则--，当计数器为0的时候，对象就不能在引用了。

这个方法原理简单，效率也很高，但是实际上单纯的引用计数法很难解决对象之间循环引用的问题。比如两个对象A和B，他们都有一个字段Object instance，然后他们用各自的instance指向对方，这样对于A和B来说，他们的引用计数器永远不会是0

### 可达性分析算法

这个算法的想法是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径成为引用链(Reference Chain)，如果某个对象无法通过GC Roots到达，我们就说这个对象是不可到达的。

![img](https://pic2.zhimg.com/v2-4f911741f95a088368869fda8724e925_b.jpg)

如图所示，object5 6 7就是GC Roots不可达的，在下一次GC回收的时候会把它们都干掉。

在Java技术体系中，可以作为GC Roots的对象有以下几种：

- 在虚拟机栈（栈帧的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
-  Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 
-  所有被同步锁（synchronized关键字）持有的对象。 
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

除了这些固定的以外，根据不同的GC和不同的内存区域，还可以有其他对象临时性地加入，共同构成完整的GC Roots集合。在局部回收中，如果只针对Java堆的某一块区域进行GC，这个区域里的对象完全有可能被别的区域的对象锁引用，这时候需要将这些关联区域的对象一并加入到GC Roots集合中去，才能保证算法的正确性。

### Again Reference

上面两个算法都和对象与对象之间的引用相关，对于引用，在之前的文章中我们讨论的仅仅是它如何确定一个对象，现在我们来再一次深入了解一下引用。

Java引用分为强引用（Strongly），软引用（Soft），弱引用（Weak）和虚引用（Phantom）。

-  强引用是最传统的引用的定义，指的是代码之中存在的引用复制，比如Object obj = new Object，无论什么情况下，只要强引用关系还存在，GC就永远不会回收他们 
-  软引用是用来描述一些还有用，但是非必须的对象，在系统内存溢出异常前，会把这些对象列入回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常 
- 弱引用也是用来描述非必须对象的，但是它们只能活到下一次GC发生为止。
- 虚引用是最弱的一种引用关系，一个对象被设置成虚引用关联的唯一目的只是为了能够在这个对象被GC的时候收到一个系统通知

### To be or not to be?

一个对象被标记成不可达后不是立刻原地去世的，它只是处于缓刑阶段，要真正的杀死一个对象，必须经过两次标记过程：在GC Roots不可达后会被第一次标记、筛选此对象是否有必要执行finalize方法。假如对象没有覆盖或者该方法已经被虚拟机调用过，那么JVM都会认为没有必要执行。

如果这个对象被判定需要执行finalize方法，那么这个对象会被放到F-Queue队列中，稍后会有一个由虚拟机自动建立的Finalizer线程去执行它们的finalize方法。

>  这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。 

一个对象想要死里逃生，只要在finalize方法中将对象重新和引用链删的任何一个对象建立关联即可，此时在第二次标记的过程中，对象就可以逃过一劫。

>  笔者并不鼓励大家使用这个方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它并不能等同于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一项妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。 

### 方法区的回收

在Java堆中，对常规应用进行一次垃圾收集通常可以回收70%-99%的内存空间，但是方法区的回收判定条件苛刻，回收的成果也非常低

在方法区的GC主要有两块内容：废弃的常量和不再使用的类型。回收废弃的常量和回收Java堆中的对象非常类似。假如常量池中有一个字符串“Java”，但是当前系统又没有任何一个字符串对象的值是“Java”，也就是没有任何字符串对象引用了“Java”，其他地方也没有引用这个字面量，那么这个时候发生GC，这个常量就会被清除出常量池，对常量池中的其他类，方法，字段的符号引用也与此类似。

判定一个类型是否属于不再使用的类型条件比较苛刻，需要同时满足下面三个条件：

- 该类所有的实例都已经被回收，也就是堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收
-  关于类加载器的部分会在后面专门介绍 
-  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。

## 参考

- [1] 深入理解Java虚拟机 周志明