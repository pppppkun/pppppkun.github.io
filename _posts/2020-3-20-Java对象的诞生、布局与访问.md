---
layout:     post
title:      Java对象的诞生、布局与访问
subtitle:   深入理解Java虚拟机
date:       2020-03-19
author:     Pkun
header-img: 
catalog: true
tags: Java虚拟机
---

## 前言

上一篇文章主要介绍了Java虚拟机运行时数据区域，这一篇将会讲解数据的其他细节，包括它们是如何创建，布局和访问的。我们所有的讨论都是基于HotSpot虚拟机和Java堆为例，所以这篇文章主要是围绕对象来讲解的。

## 对象的创建

### 空间的划分

通常我们创建一个对象的代码就是A a = new A()，也可以利用反射来创建对象，当JVM遇到一条字节码new指令的时候，首先会去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用（上一篇文章有讲运行时常量池的一些细节），并且查看这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有还要先执行相应的类加载过程，这个会在后面详细介绍。

如果类加载过，接下来JVM就要对这个新生对象分配一定的内存。上一篇文章我们讲过，Java堆在逻辑上是连续的，物理上是不连续的，已经使用的内存和没有使用的内存相互交错。

因此虚拟机必须维护一个列表，上面记录了哪些内存块是可用的，在分配的时候要找到一个足够大的块划分给对象，然后更新列表上的记录，这种分配方式叫做**空闲列表（Free List）**

对计算机系统有了解的朋友们会发现这种分配方式其实非常像系统内存管理中的**Partitioning**

![img](https://pic3.zhimg.com/v2-ca487b31d49fc4d3f9977adb0dae9272_b.png)

如果我们的代码放进内存的时候没有占满一个最小的块（内存是分块的），那么这个快就会被细分，到最后可能会出现很多细小的没法被使用的内存，这时候就需要我们进行碎片收集，重新分配内存。

如果**GC**可以做到空间压缩整理（就是上面这一段），那么我们可以使用**指针碰撞（Bump the pointer）**的方法来分配内存，这个时候Java堆是规整的，物理上是连续的。指针碰撞就是有一个指针来区分空闲的空间和使用的空间，当我们需要分配新的空间的时候，将指针移动一下就可以了。

### 线程安全

除了划分可用空间以外，我们还需要考虑分配过程中的线程安全问题。

可能存在我们正在给对象A分配内存，指针还没来得及修改，线程的时间片段已经用完，轮到另一个线程创建对象B，使用的是同样的指针1的情况。

解决这个问题有两个方案，一个是分配内存空间动作的同步处理，即虚拟机采用[CAS（Compare and Swap）](https://www.jianshu.com/p/ab2c8fce878b)配上失败重试的方式更新操作的原子性。

另一种方案是把内存分配的动作按照线程划分在不同的空间中进行，上一篇文章我们讲到：

>  所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）来提升对象分配时的效率。TLAB的能够让每个Java线程能使用自己专属的分配指针来分配空间，均摊对Java堆里共享的分配指针做更新而带来的同步开销. 

哪个线程需要分配内存，就在哪个线程的TLAB内分配，只有TLAB用完了后，分配新的缓存的时候才需要同步锁定，虚拟机是否使用TLAB可以通过-XX: +/-UseTLAB参数来设置

分配完内存后，JVM必须分配到的内存空间（除了对象头）都初始化为0，如果使用了TLAB，那么初始化也可以提前到TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

最后，JVM还要对对象进行设置，比如对象是哪个类的实例，如何找到它的元数据，它的GC分代年龄等信息。这些信息会被放在对象头中。

到这里，从JVM的视角出发，一个新的对象已经产生了，但是从Java程序的视角来看，对象的构造函数<init>()方法还没有执行，所有的字段都是默认的0值。new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

## 对象的内存布局

在HotSpot中，对象在堆内存中的存储布局可以划分为三个部分：对象头，实例数据和对齐填充

### 对象头

对象头包括两类信息，一类是用于存储对象自身运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁等。

另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。

### 实例数据

就是代码里面定义的各种类型的字段内容，包括从父类中继承下来的。这部分的存储顺序收到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。一般来说，占用bit较多，从父类中继承来的变量会放在靠前的位置。

对齐填充只是为了满足对象的起始地址必须是8字节的整数倍

## 对象的访问定位

上一篇文章说过，Java中取消了指针的概念，取而代之的是**引用（reference）**，Java程序就是通过栈上的引用数据来操作堆上的具体对象。其中reference定位和访问堆中对象的方法有两种：句柄和直接指针。

### 句柄

![img](https://pic2.zhimg.com/v2-45c74a6a49fdd7fcff3c322e57b82f49_b.png)

句柄就是在Java堆中划分了一个句柄池，reference是指向对象在句柄池中的地址。句柄中包含了对象的实例数据和类型数据各自的具体的地址信息。

### 直接指针

![img](https://pic1.zhimg.com/v2-1a2b85c2f21eea914103807d42bc01d0_b.png)

直接指针就是reference直接指向了对象地址，如果只是访问对象本身，那么就不需要多一次间接寻址的开销

使用句柄的好处就是reference中存储的是稳定句柄地址，在对象被移动时（GC时移动对象非常普遍），只需要改变句柄中实例数据的指针，而使用直接指针的好处就是速度更快，HotSpot主要使用的是直接指针。

## 参考

- [1] 深入理解Java虚拟机，周志明