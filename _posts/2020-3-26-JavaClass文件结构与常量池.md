---
layout:     post
title:      Java .class文件结构与常量池
subtitle:   深入理解Java虚拟机
date:       2020-03-26
author:     Pkun
header-img: 
catalog: true
tags: Java虚拟机


---

## 前言

在命令行中使用javac <file>.java会出现一个<file>.class的文件，其实这就是用Java编译器将普通的Java文件编译成了在任意平台上都可以使用的字节码文件，这就是Java的“一次编写，到处运行”。

## 无关性的基石

所有平台的Java虚拟机都支持统一的程序存储格式**字节码**，其实在现在也有很多Java以外的语言能够使用Java虚拟机，如JPython,JRuby等等。Java虚拟机不与任何程序语言相绑定，而是只与class文件相关联。

class文件中包含了Java虚拟机的指令集，符号表以及若干其他辅助信息。

![img](https://pic3.zhimg.com/v2-033a76bab255c88bdf1b22ae07baaf42_b.png)

## class文件的结构

任何一个class文件应该都对应着唯一的一个类或者接口的定义信息，但是有的类或者接口是动态生成的，直接送入到类加载器中，这些类和接口并不一定都得定义在文件里面

class文件是一组以8个字节为基础单位的二进制流，各个数据部分时严格地按照顺序紧凑地排列在文件之中，没有任何分隔符，当需要使用8个字节以上的空间数据项时采用高位读取，采用一种类似于C结构体的结构来存放数据，这种结构只有两种数据类型：无符号数和表

>  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表 

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式

Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在数据项中无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变。

![img](https://pic3.zhimg.com/v2-9d2ba0783a587a4945b70f6748018152_b.png)

### 魔数与class文件版本

每个class文件开头的4个字节0xCAFEBABE是标识一个文件是否可以作为被虚拟机接受的class文件的魔数。实际上很多文件格式标准种都有魔数，比如图片格式。使用魔数而不是拓展名来进行识别主要是基于安全考虑，因为扩展名是可以随意改变的。

紧接着第4个字节存储的是class文件的版本号，第5，第6个字节是次版本号，第7，第8个字节是主版本号。

将下面这段代码编译成class文件后用十六进制编辑器打开就可以看到0xCAFEBABE了

```
public class TestClass {
    private int m;
    public int inc() {
        return m + 1;
    }
}
```

![img](https://pic1.zhimg.com/v2-2cc96f87490b304d23b344faa7b4f4c0_b.png)

因为我使用的是JDK8，对应的版本号就是52.0，翻译成十六进制就是第七个字节0x34

### 常量池

在主版本号后面的就是常量池入口，常量池就是class文件之中的资源仓库，是class文件结构中与其他项目关联最多的数据，也是class文件中空间最大的数据项目之一。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的。因为在后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，就可以把索引值设置为0。

class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型都是从0开始的。

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或者开放的包（Package）
- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

常量池的表结构为

```
cp_info{
    u1 tag;
    u1 info[];
}
```

Java代码在编译的时候并没有GCC的链接这一步骤，在JVM加载Class文件的时候才会进行动态连接，当虚拟机做类加载的时候，会从常量池获得对应的符号引用，然后再在类创建时或运行时解析，翻译到具体的内存地址只中。

常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，在JDK13中，常量表中国一共有17种不同类型的常量

![img](https://pic1.zhimg.com/v2-62a1af5dc32545b96d0df9c4a0aa1f34_b.png)

![img](https://pic2.zhimg.com/v2-bfe18fd64e730293b3828f103764ed05_b.png)

表结构起始的第一位是个u1类型的标志位，代表当前的常量属于哪种常量类型。这17种常量类型各自有着完全独立的数据结构。在之前那段代码产生的.class文件中，他的第一项常量0x0000000A是0A

![img](https://pic1.zhimg.com/v2-aecaeacd33da88988136e62af6af8500_b.png)

表示他是类中的方法的符号引用，这个类型的结构为

![img](https://pic1.zhimg.com/v2-b50846eb96f12863610609f6ac5c6dfc_b.png)

然后我们往后继续找两个字节，他对应了两个索引，分别是4和15，表示对应了具体位置在第四和第十五个常量表位置的索引。接下来是09，对应字符的符号引用，找到两个索引，分别是3和16，表示对应了具体位置在第3和第16个常量表位置。接下来是7，对应的是类和接口的符号引用，往后的一个索引17表明在第17个常量表位置，再接着又是一个7，对应了常量表第18个位置的常量，再接着是1，表示一个UTF-8字符串，1后面跟着1和6D，表明只有一个字节的字符串内容，内容为6D，是ASCII的m。

我们可以使用javap -verbose <class文件>来读取常量表

![img](https://pic2.zhimg.com/v2-e629753f5405f6478de9c25160d86679_b.png)

>  顺便提一下，由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名 称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的 最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。

读出来的这个表中还有一些不在我们代码里面出现的东西，比如()V,()I,LineNumberTable，inc等，这些都是编译器自动生成的，被字段表，方法表，属性表所引用，它们会被用来描述一些不适合使用固定字节表达的内容，比如方法的参数个数，返回值等

最后附上常量池中不同数据结构的结构总表

![img](https://pic1.zhimg.com/v2-d93dde10ca95d761eea710e2bb2fb3c4_b.png)

![img](https://pic1.zhimg.com/v2-64b6d12c80168e6b4e6b604c9e783bb0_b.png)

![img](https://pic2.zhimg.com/v2-c12267ad160a662443c1971e3aaa0841_b.png)

### 参考

- [1] 深入理解Java虚拟机 周志明