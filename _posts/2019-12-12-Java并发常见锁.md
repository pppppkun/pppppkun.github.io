---
layout:     post
title:      Java锁的分类
subtitle:   Java基础知识
date:       2019-12-12
author:     Pkun
header-img: img/Java-basic.jpg
catalog: true
tags:
    - 并发
    - 锁
---

# 锁

安全性和活跃度通常相互牵制。我们使用锁来保证线程安全，但是滥用锁可能引起锁顺序死锁。类似地，我们使用线程池和信号量来约束资源的使用，

但是缺不能知晓哪些管辖范围内的活动可能形成的资源死锁。Java应用程序不能从死锁中恢复，所以确保你的设计能够避免死锁出现的先决条件是非常有价值。

## 乐观锁/悲观锁

乐观锁与悲观锁并不是特指某两种类型的锁，是人们定义出来的概念或思想，主要是指看待并发同步的角度。

### 乐观锁

乐观锁总是认为不存在并发问题，每次去取数据的时候，总认为不会有其他线程对数据进行修改，因此不会上锁。但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用“数据版本机制”或“CAS操作”来实现。

乐观锁比较适用于多读的逻辑中，可以提高很多吞吐量，在java中`java.util.concurrent.atomic`包里面有一个原子变量类就是使用了乐观锁的一种实现方式`Compare and Swap`实现的。


#### 数据版本机制

实现数据版本一般有两种，第一种是使用版本号，第二种是使用时间戳。

版本号方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。


#### CAS操作

当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS操作中包含三个操作数——需要读写的内存位置(V)、进行比较的预期原值(A)和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B，否则处理器不做任何操作。


### 悲观锁

悲观锁认为对于同一个数据的并发操作，一定会发生修改的，哪怕没有修改，也会认为修改。因此对于同一份数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁并发操作一定会出问题。

在对数据修改前，应该先为你要修改的数据加上排他锁`exclusive locking`，如果加锁失败，说明记录正在被修改，当前进程就要等待或者抛出异常

## 独享锁/共享锁

### 独享锁

独享锁就是说这个锁一次只能被一个线程持有

### 共享锁

共享锁就是说这个锁可以被多个线程持有


## 互斥锁/读写锁

这两个锁就是上面两种广义锁的具体实现

## 可重入锁

可重入锁就是如果某个线程试图获取一个已经由他自己持有的锁,这个请求可以成功

```java
public void get() {
        lock.lock();
        System.out.println(Thread.currentThread().getId());
        set();
        lock.unlock();
    }

public void set() {
        lock.lock();
        System.out.println(Thread.currentThread().getId());
        lock.unlock();
}
```

## 公平锁/非公平锁

### 公平锁

公平锁指的是多个线程按照申请锁的顺序来获取锁

### 非公平锁

多个线程获取锁的顺序并不是按照申请锁的顺序

对于`ReetrantLock`来说，可以通过构造函数来指定这个锁是否是公平锁，默认为非公平锁，因为非公平锁的吞吐量比公平锁大

对于`Synchronized`来说，它也是一种非公平锁，但是它不像`ReetrantLock`那样通过`AQS`来实现线程调度，所以没有任何办法让他变成公平锁。

#### AQS

`AbstractQueuedSynchronizer`为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁定和相关同步器（信号量、事件，等等）提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。子类必须定义更改此状态的受保护方法，并定义哪种状态对于此对象意味着被获取或被释放。假定这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。但只是为了获得同步而只追踪使用 getState()、setState(int) 和 compareAndSetState(int, int) 方法来操作以原子方式更新的 int 值。


> 这个以后再讲

## 分段锁



分段锁其实是一种锁的设计，并不是具体的一种锁，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

我们以`ConcurrentHashMap`来说一下分段锁的含义以及设计思想，`ConcurrentHashMap`中的分段锁称为`Segment`，它即类似于`HashMap`（`JDK7`和`JDK8`中`HashMap`的实现）的结构，即内部拥有一个`Entry`数组，数组中的每个元素又是一个链表；同时又是一个`ReentrantLock`（`Segment`继承了`ReentrantLock`）。

当需要put元素的时候，并不是对整个`hashmap`进行加锁，而是先通过`hashcode`来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。

但是，在统计size的时候，可就是获取`hashmap`全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。


## 偏向锁/轻量级锁/重量级锁

这三种锁是指锁的状态，并且是针对`Synchronized`。在Java 5通过引入锁升级的机制来实现高效`Synchronized`。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

### 轻量级锁

轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

### 重量级锁

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。

## 自旋锁

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

